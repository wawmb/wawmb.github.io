[{"categories":null,"content":"黄艳杰简历  概况：三年多工作经验 | 男 | 25岁(1996年12月22日) | 未婚 | 177cm 电话：15606902050 E-mail： wawmmb@sina.cn 地址：福建莆田 行业：嵌入式/物联网/消费电子 职位：资深软件工程师 学校：厦门工学院 学历：本科 专业：电子信息工程  工作经历 2020.3~至今：捷星显示科技（福建）有限公司 2年 职位: 资深软件工程师 部门：产品研发部\n商显项目  负责商业显示器等大屏幕带安卓系统显示器的Linux调试debug，配合厂内QA部门通过应用层调试其相应功能，以及分析QA所提问题，输出商显机种对应软件工程规格。\n 负责21.5寸液晶产品的液晶模组的开发与维护，从新机种开始跟进，液晶参数的测试，到试产不良的分析与解决，对应21.5寸的BOM维护，以及CAS的数据整理与制作。对应机种InterFace和FT治具的分析和调试设计。\n安卓项目  负责基于Android上JavaScript自动化和编程的Autojs软件，根据产品测试需求所开发商显安卓主板intent.setAction广播APP，shell脚本APP，进行安卓主板外设的通讯，用于产线功能调测。\n个人项目  一款休闲娱乐小程序，已按微信小程序要求进行优化过审，对接淘宝联盟，美团联盟，饿了么联盟。通过wx.request发起HTTPS网络请求，实现云更新，云操作后台管理。\n 基于ESP8266、ESP32-CAM所开发设计智能家居设备，含温度检测，灯条控制，电脑WOL唤醒，智能摄像车等多个物联网智能家居项目。\n2018.11~2020.3：厦门致杰智能科技有限公司 1年4个月 职位: 电子工程师 部门：电子研发部\n卫浴项目  负责B08,T10,T16新产品的开发，原理图绘制PCB布局，打样测试，整机EMC测试。出CAD图纸检标封样，对应板的测试工装，编写测试程序，制定测试操作文件。参与试制，试产，处理生产问题。\n 基于OB2576芯片为核心开发设计一款12V稳压输出的开关电源。 基于合泰芯片BS84B08A-3设计泡沫盾板原理图PCB，并编写其对应触摸功能程序。 基于新唐芯片MS51FB9AE和霍尔感应原件设计旋钮板原理图PCB，并编写其对应旋钮程序。 基于新唐芯片MS51FB9AE和数码管设计显示板原理图PCB，并编写其对应显示程序。 使用新唐、合泰、stm32等IC编写过零检测测试程序、步进电机老化程序、显示板显示程序、旋钮程序、紫外杀菌程序等相关程序与主板进行通讯，以及使用CAD完成相关绘图等。  米家项目  配合北京小米米家要求，结合公司产品做相关iot测试，协助小米米家小鲸洗系列小程序上线。\n2018.07：福建省大学生电子设计竞赛 三等奖\n电赛项目  基于单片机、无线充电模块和4路红外发射接收模块，通过单片机延时程序实现一分钟的定时充电，并根据红外接收情况实现小车爬坡循迹行驶。\n教育背景 2015.09~2019.07：厦门工学院 电子信息工程专业\n 主修课程：模拟电子技术基础、数字电路、单片微机原理及应用、嵌入式系统技术与分析等。\n 连续两年获得国家励志奖学金，获得福建省大学生电子设计竞赛三等奖。\n技能证书  语言能力：大学英语四级 计算机能力：计算机二级 Layout：Altium Designer/立创EDA 绘图工具：CAD/PS 编程工具：Visual Studio/Arduino/Keli/HT-IDE3000/IAR 静态网页：Hugo/github 云和开放平台：微信小程序开发  自我评价  3年多嵌入式电子工作经验，嵌入式项目经验丰富。熟练掌握硬件原理图PCB开发绘制打样等流程，AD等绘图软件使用，熟悉多种常用单片机编程，有完整软件逻辑分析能力，能独立完成软件的编写。熟悉安卓开发环境，熟悉LINUX基本命令，有个人hugo网站搭建和多种物联网智能家居项目以及个人微信小程序实现的经历。同时，我具备良好的沟通能力和团队协作能力，能快速融入团队。\n致谢  感谢您花时间阅读我的简历，期待能有机会和您共事。\n","date":"2022-01-16","img":"","permalink":"/zh-cn/about/","series":null,"tags":null,"title":"简历"},{"categories":["安卓自动化"],"content":"Auto.JS简介  Auto.JS是Android平台上的JavaScript自动化工具。它的本质是可执行自己编写的简易Javascript脚本的，尤其可以在开启“无障碍模式”的情况下对其他App进行一些操作的一个Android App，便于进行自动化操作。\n项目实现  通过代码，最大程度的简化安卓主板IO的控制逻辑，根据产品测试需求所开发商显安卓主板intent.setAction广播APP，shell脚本APP，进行安卓主板外设的通讯，用于产线功能调测，降低产线的测试难度。\n具体步骤  使用之前，我们先导入需要用到的安卓的class，以及注册广播。\n1importClass(android.content.IntentFilter); 2 3let intent = new Intent(); 4let filter = new IntentFilter(); 5filter.addAction(Intent.ACTION_BATTERY_CHANGED); 6filter.addAction(\u0026#34;android.intent.action.Dustin\u0026#34;); 7filter.addAction(\u0026#34;com.fise.system.reboot\u0026#34;); 8filter.addAction(\u0026#34;echo 1 \u0026gt; /sys/class/fise_gpio5/level\u0026#34;); 9filter.addAction(\u0026#34;echo 0 \u0026gt; /sys/class/fise_gpio5/level\u0026#34;); 10filter.addAction(\u0026#34;echo 1 \u0026gt; /sys/class/fise_gpio6/level\u0026#34;); 11filter.addAction(\u0026#34;echo 0 \u0026gt; /sys/class/fise_gpio6/level\u0026#34;); 12filter.addAction(\u0026#34;echo 1 \u0026gt; /sys/class/fise_gpio7/level\u0026#34;); 13filter.addAction(\u0026#34;echo 0 \u0026gt; /sys/class/fise_gpio7/level\u0026#34;); 14filter.addAction(Intent.ACTION_SCREEN_ON);  以 安卓广播 为例：\n1var action = \u0026#34;echo 0 \u0026gt; /sys/class/fise_gpio6/level\u0026#34;; 2 app.sendBroadcast({ 3 action: action, 4 extras: { 5 author: \u0026#34;Dustin\u0026#34;, 6 }, 7 });  以 安卓shell 为例：\n1var result = shell(\u0026#34;echo 0 \u0026gt; /sys/class/fise_gpio5/level\u0026#34;, false); 2 toast(result);  UI人机交互部分：\n1ui.layout( 2 \u0026lt;vertical\u0026gt; 3 \u0026lt;card padding=\u0026#34;10\u0026#34; w=\u0026#34;*\u0026#34; h=\u0026#34;auto\u0026#34; margin=\u0026#34;5 5 5 5\u0026#34; cardCornerRadius=\u0026#34;20dp\u0026#34; cardBackgroundColor=\u0026#34;#72ffffff\u0026#34; cardElevation=\u0026#34;1dp\u0026#34; alpha=\u0026#34;0.8\u0026#34; cardCornerRadius=\u0026#34;30dp\u0026#34;\u0026gt; 4 \u0026lt;horizontal margin=\u0026#34;20 10 20 5\u0026#34; gravity=\u0026#34;center\u0026#34; \u0026gt; 5 \u0026lt;button id=\u0026#34;open\u0026#34; text=\u0026#34;打开广播\u0026#34; layout_weight=\u0026#34;1\u0026#34; style=\u0026#34;Widget.AppCompat.Button.Colored\u0026#34; /\u0026gt;; 6 \u0026lt;button id=\u0026#34;cq\u0026#34; text=\u0026#34;重启\u0026#34; layout_weight=\u0026#34;1\u0026#34; style=\u0026#34;Widget.AppCompat.Button.Colored\u0026#34; /\u0026gt;; 7 \u0026lt;button id=\u0026#34;close\u0026#34; text=\u0026#34;关闭广播\u0026#34; layout_weight=\u0026#34;1\u0026#34; style=\u0026#34;Widget.AppCompat.Button.Colored\u0026#34; /\u0026gt;; 8 \u0026lt;/horizontal\u0026gt; 9 \u0026lt;/card\u0026gt; 10 \u0026lt;card padding=\u0026#34;10\u0026#34; w=\u0026#34;*\u0026#34; h=\u0026#34;auto\u0026#34; margin=\u0026#34;5 5 5 5\u0026#34; cardCornerRadius=\u0026#34;20dp\u0026#34; cardBackgroundColor=\u0026#34;#72ffffff\u0026#34; cardElevation=\u0026#34;1dp\u0026#34; alpha=\u0026#34;0.8\u0026#34; cardCornerRadius=\u0026#34;30dp\u0026#34;\u0026gt; 11 \u0026lt;horizontal margin=\u0026#34;20 10 20 5\u0026#34; gravity=\u0026#34;center\u0026#34; \u0026gt; 12 \u0026lt;text text=\u0026#34;选择电平:\u0026#34; textColor=\u0026#34;black\u0026#34; w=\u0026#34;auto\u0026#34; /\u0026gt; 13 \u0026lt;spinner id=\u0026#34;选择电平7\u0026#34; textStyle=\u0026#34;bold\u0026#34; entries=\u0026#34;高电平|低电平\u0026#34; spinnerMode=\u0026#34;dialog\u0026#34; /\u0026gt; 14 \u0026lt;button id=\u0026#34;设置GPIO7\u0026#34; text=\u0026#34;设置GPIO7\u0026#34; layout_weight=\u0026#34;1\u0026#34; style=\u0026#34;Widget.AppCompat.Button.Colored\u0026#34; /\u0026gt;; 15 \u0026lt;/horizontal\u0026gt; 16 \u0026lt;/card\u0026gt; 17 \u0026lt;card padding=\u0026#34;10\u0026#34; w=\u0026#34;*\u0026#34; h=\u0026#34;auto\u0026#34; margin=\u0026#34;5 5 5 5\u0026#34; cardCornerRadius=\u0026#34;20dp\u0026#34; cardBackgroundColor=\u0026#34;#72ffffff\u0026#34; cardElevation=\u0026#34;1dp\u0026#34; alpha=\u0026#34;0.8\u0026#34; cardCornerRadius=\u0026#34;30dp\u0026#34;\u0026gt; 18 \u0026lt;horizontal margin=\u0026#34;20 10 20 5\u0026#34; gravity=\u0026#34;center\u0026#34; \u0026gt; 19 \u0026lt;text text=\u0026#34;选择电平:\u0026#34; textColor=\u0026#34;black\u0026#34; w=\u0026#34;auto\u0026#34; /\u0026gt; 20 \u0026lt;spinner id=\u0026#34;选择电平8\u0026#34; textStyle=\u0026#34;bold\u0026#34; entries=\u0026#34;高电平|低电平\u0026#34; spinnerMode=\u0026#34;dialog\u0026#34; /\u0026gt; 21 \u0026lt;button id=\u0026#34;设置GPIO8\u0026#34; text=\u0026#34;设置GPIO8\u0026#34; layout_weight=\u0026#34;1\u0026#34; style=\u0026#34;Widget.AppCompat.Button.Colored\u0026#34; /\u0026gt;; 22 \u0026lt;/horizontal\u0026gt; 23 \u0026lt;/card\u0026gt; 24 \u0026lt;card padding=\u0026#34;10\u0026#34; w=\u0026#34;*\u0026#34; h=\u0026#34;auto\u0026#34; margin=\u0026#34;5 5 5 5\u0026#34; cardCornerRadius=\u0026#34;20dp\u0026#34; cardBackgroundColor=\u0026#34;#72ffffff\u0026#34; cardElevation=\u0026#34;1dp\u0026#34; alpha=\u0026#34;0.8\u0026#34; cardCornerRadius=\u0026#34;30dp\u0026#34;\u0026gt; 25 \u0026lt;horizontal margin=\u0026#34;20 10 20 5\u0026#34; gravity=\u0026#34;center\u0026#34; \u0026gt; 26 \u0026lt;text text=\u0026#34;选择电平:\u0026#34; textColor=\u0026#34;black\u0026#34; w=\u0026#34;auto\u0026#34; /\u0026gt; 27 \u0026lt;spinner id=\u0026#34;选择电平9\u0026#34; textStyle=\u0026#34;bold\u0026#34; entries=\u0026#34;高电平|低电平\u0026#34; spinnerMode=\u0026#34;dialog\u0026#34; /\u0026gt; 28 \u0026lt;button id=\u0026#34;设置GPIO9\u0026#34; text=\u0026#34;设置GPIO9\u0026#34; layout_weight=\u0026#34;1\u0026#34; style=\u0026#34;Widget.AppCompat.Button.Colored\u0026#34; /\u0026gt;; 29 \u0026lt;/horizontal\u0026gt; 30 \u0026lt;/card\u0026gt; 31 \u0026lt;/vertical\u0026gt; 32);  UI点击事件：\n1ui.设置GPIO9.on(\u0026#34;click\u0026#34;, () =\u0026gt; { 2 var i = ui.选择电平9.getSelectedItemPosition(); 3 switch (i) { 4 case 0: 5 toast(\u0026#34;您选择的高电平！\u0026#34;); 6 var action = \u0026#34;echo 1 \u0026gt; /sys/class/fise_gpio7/level\u0026#34;; 7 app.sendBroadcast({ 8 action: action, 9 extras: { 10 author: \u0026#34;yashu\u0026#34;, 11 }, 12 }); 13 var result = shell(\u0026#34;echo 1 \u0026gt; /sys/class/fise_gpio7/level\u0026#34;, false); 14 toast(result); 15 break; 16 case 1: 17 var action = \u0026#34;echo 0 \u0026gt; /sys/class/fise_gpio7/level\u0026#34;; 18 app.sendBroadcast({ 19 action: action, 20 extras: { 21 author: \u0026#34;yashu\u0026#34;, 22 }, 23 }); 24 var result = shell(\u0026#34;echo 0 \u0026gt; /sys/class/fise_gpio7/level\u0026#34;, false); 25 toast(result); 26 toast(\u0026#34;您选择的低电平！\u0026#34;); 27 break; 28 } 29});  本文完整源码已上传本人gitee，点击查看。\n","date":"2021-06-27","img":"","permalink":"/zh-cn/docs/autojs/","series":["文档"],"tags":["安卓"],"title":"安卓自动化"},{"categories":["Markdown"],"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks 1\u0026lt;!doctype html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 5 \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; 9\u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1\u0026lt;!doctype html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 5 \u0026lt;title\u0026gt;Another Example HTML5 Document\u0026lt;/title\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 \u0026lt;p\u0026gt;A looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong text\u0026lt;/p\u0026gt; 9\u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested List  Fruit  Apple Orange Banana   Dairy  Milk Cheese    TODO List  Done WIP  Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"2021-02-09","img":"/images/markdown.png","permalink":"/zh-cn/posts/markdown-syntax/","series":["文档"],"tags":["Markdown","CSS","HTML"],"title":"Markdown 语法指南"},{"categories":["微信小程序"],"content":"微信小程序简介  小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。\n项目实现  通过微信小程序的便捷型快应用方式，聚合饿了吗联盟，美团联盟CPS推广，以及小游戏、抽签项目，抽签自定义，实现纠结症福音。\n具体步骤 一、申请一个小程序\n 申请地址：微信公众平台，申请小程序的操作很简单，大家百度一下跟着步骤申请就行。\n二、下载微信开发者工具\n三、部分代码分享\n 网页编程采用的是 HTML + CSS + JS 这样的组合，其中 HTML 是用来描述当前这个页面的结构，CSS 用来描述页面的样子，JS 通常是用来处理这个页面和用户的交互。在小程序中也有同样的角色，其中 WXML 充当的就是类似 HTML 的角色。\n 以 WXML 为例：\n1\u0026lt;view class=\u0026#34;container\u0026#34;\u0026gt; 2 \u0026lt;swiper class=\u0026#34;tab1\u0026#34; indicator-dots=\u0026#34;{{indicatorDots}}\u0026#34; autoplay=\u0026#34;{{autoplay}}\u0026#34; interval=\u0026#34;{{interval}}\u0026#34; duration=\u0026#34;{{duration}}\u0026#34; circular=\u0026#34;true\u0026#34;\u0026gt; 3 \u0026lt;block wx:for=\u0026#34;{{imgUrls}}\u0026#34; wx:key=\u0026#34;unique\u0026#34;\u0026gt; 4 \u0026lt;swiper-item\u0026gt; 5 \u0026lt;image src=\u0026#34;{{item}}\u0026#34; class=\u0026#34;slide-image\u0026#34; /\u0026gt; 6 \u0026lt;/swiper-item\u0026gt; 7 \u0026lt;/block\u0026gt; 8 \u0026lt;/swiper\u0026gt; 9 10 \u0026lt;v-tabs class=\u0026#34;tab\u0026#34; vue-id=\u0026#34;8dd740cc-1\u0026#34; tabs=\u0026#34;{{tabs}}\u0026#34; value=\u0026#34;{{current}}\u0026#34; data-event-opts=\u0026#34;{{[[\u0026#39;^change\u0026#39;,[[\u0026#39;changeTab\u0026#39;]]],[\u0026#39;^input\u0026#39;,[[\u0026#39;__set_model\u0026#39;,[\u0026#39;\u0026#39;,\u0026#39;current\u0026#39;,\u0026#39;$event\u0026#39;,[]]]]]]}}\u0026#34; bind:change=\u0026#34;__e\u0026#34; bind:input=\u0026#34;__e\u0026#34; bind:__l=\u0026#34;__l\u0026#34;\u0026gt;\u0026lt;/v-tabs\u0026gt; 11 12 \u0026lt;view class=\u0026#34;movie\u0026#34;\u0026gt; 13 \u0026lt;view class=\u0026#34;movie-head\u0026#34;\u0026gt; 14 \u0026lt;view class=\u0026#34;movie-title\u0026#34;\u0026gt;热映电影\u0026lt;/view\u0026gt; 15 \u0026lt;view class=\u0026#34;movie-count\u0026#34;\u0026gt;全部46部\u0026lt;/view\u0026gt; 16 \u0026lt;/view\u0026gt; 17 \u0026lt;view class=\u0026#34;movie-list\u0026#34;\u0026gt; 18 \u0026lt;view class=\u0026#34;item\u0026#34;\u0026gt; 19 \u0026lt;image class=\u0026#34;cover\u0026#34; src=\u0026#34;https://www.hualigs.cn/image/61cd410fc19ac.jpg\u0026#34; mode\u0026gt;\u0026lt;/image\u0026gt; 20 \u0026lt;view class=\u0026#34;name\u0026#34;\u0026gt;寻龙传说\u0026lt;/view\u0026gt; 21 \u0026lt;view class=\u0026#34;buy\u0026#34;\u0026gt;已售空\u0026lt;/view\u0026gt; 22 \u0026lt;/view\u0026gt; 23 \u0026lt;view class=\u0026#34;item\u0026#34;\u0026gt; 24 \u0026lt;image class=\u0026#34;cover\u0026#34; src=\u0026#34;https://www.hualigs.cn/image/61cd4146cc8c6.jpg\u0026#34; mode\u0026gt;\u0026lt;/image\u0026gt; 25 \u0026lt;view class=\u0026#34;name\u0026#34;\u0026gt;无依之地\u0026lt;/view\u0026gt; 26 \u0026lt;view class=\u0026#34;buy\u0026#34;\u0026gt;已售空\u0026lt;/view\u0026gt; 27 \u0026lt;/view\u0026gt; 28 \u0026lt;view class=\u0026#34;item\u0026#34;\u0026gt; 29 \u0026lt;image class=\u0026#34;cover\u0026#34; src=\u0026#34;https://www.hualigs.cn/image/61cd41b0c46ae.jpg\u0026#34; mode\u0026gt;\u0026lt;/image\u0026gt; 30 \u0026lt;view class=\u0026#34;name\u0026#34;\u0026gt;唐人街探案3\u0026lt;/view\u0026gt; 31 \u0026lt;view class=\u0026#34;buy\u0026#34;\u0026gt;已售空\u0026lt;/view\u0026gt; 32 \u0026lt;/view\u0026gt; 33 \u0026lt;view class=\u0026#34;item\u0026#34;\u0026gt; 34 \u0026lt;image class=\u0026#34;cover\u0026#34; src=\u0026#34;https://www.hualigs.cn/image/61cd41ce7e7f4.jpg\u0026#34; mode\u0026gt;\u0026lt;/image\u0026gt; 35 \u0026lt;view class=\u0026#34;name\u0026#34;\u0026gt;送你一朵小红花\u0026lt;/view\u0026gt; 36 \u0026lt;view class=\u0026#34;buy\u0026#34;\u0026gt;已售空\u0026lt;/view\u0026gt; 37 \u0026lt;/view\u0026gt; 38 \u0026lt;/view\u0026gt; 39 \u0026lt;/view\u0026gt; 40 41 \u0026lt;view data-ref=\u0026#34;coupon\u0026#34; class=\u0026#34;coupon vue-ref\u0026#34;\u0026gt; 42 \u0026lt;block wx:for=\u0026#34;{{couponList}}\u0026#34; wx:for-item=\u0026#34;v\u0026#34; wx:for-index=\u0026#34;i\u0026#34; wx:key=\u0026#34;i\u0026#34;\u0026gt; 43 \u0026lt;view data-event-opts=\u0026#34;{{[[\u0026#39;tap\u0026#39;,[[\u0026#39;toCoupon\u0026#39;,[i]]]]]}}\u0026#34; class=\u0026#34;item\u0026#34; bindtap=\u0026#34;__e\u0026#34;\u0026gt; 44 \u0026lt;view class=\u0026#34;top\u0026#34;\u0026gt; 45 \u0026lt;view class=\u0026#34;left\u0026#34;\u0026gt; 46 \u0026lt;view class=\u0026#34;content\u0026#34;\u0026gt; 47 \u0026lt;image class=\u0026#34;icon\u0026#34; src=\u0026#34;{{v.icon}}\u0026#34; mode=\u0026#34;widthFix\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; 48 \u0026lt;view class=\u0026#34;name\u0026#34;\u0026gt;{{v.name}}\u0026lt;/view\u0026gt; 49 \u0026lt;/view\u0026gt; 50 51 \u0026lt;view class=\u0026#34;text\u0026#34;\u0026gt;{{v.type}}\u0026lt;/view\u0026gt; 52 \u0026lt;!-- \u0026lt;block wx:if=\u0026#34;{{v.type==1}}\u0026#34;\u0026gt; 53\u0026lt;view class=\u0026#34;text\u0026#34;\u0026gt;天天可领\u0026lt;/view\u0026gt; 54\u0026lt;/block\u0026gt; 55\u0026lt;block wx:else\u0026gt; 56\u0026lt;block wx:if=\u0026#34;{{v.type==2}}\u0026#34;\u0026gt; 57\u0026lt;view class=\u0026#34;text\u0026#34;\u0026gt;限时秒杀\u0026lt;/view\u0026gt; 58\u0026lt;/block\u0026gt; 59\u0026lt;/block\u0026gt; --\u0026gt; 60 61 \u0026lt;/view\u0026gt; 62 \u0026lt;view class=\u0026#34;right\u0026#34;\u0026gt;点击查看\u0026lt;/view\u0026gt; 63 \u0026lt;/view\u0026gt; 64 \u0026lt;view class=\u0026#34;bottom\u0026#34;\u0026gt; 65 \u0026lt;image src=\u0026#34;{{v.bannerPic}}\u0026#34; mode=\u0026#34;widthFix\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; 66 \u0026lt;/view\u0026gt; 67 \u0026lt;/view\u0026gt; 68 \u0026lt;/block\u0026gt; 69 \u0026lt;/view\u0026gt; 70\u0026lt;/view\u0026gt;  WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。\n 以 WXSS 为例：\n1page { 2 background-color: #f8f8f8 3} 4 5.container { 6 font-size: 14px; 7 line-height: 24px; 8 position: relative 9} 10.container .tab1 { 11 padding-top: 0rpx; 12 width: 750rpx; 13 height: 280rpx; 14} 15 16/* 修改dot形状 */ 17.wx-swiper-dots .wx-swiper-dot{ 18 width: 14rpx; 19 height: 14rpx; 20 margin: 0 6rpx; 21 border-radius: 20rpx; 22 transition: all .5s; 23 background-color: rgba(0, 0, 0, .3) 24} 25.wx-swiper-dots .wx-swiper-dot-active{ 26 width: 34rpx; 27 background-color: hsla(0, 0%, 100%, .8) 28} 29/* 调成dots的位置 */ 30.wx-swiper-dots.wx-swiper-dots-horizontal { 31 top: 80%; 32} 33.wx-swiper-dots .wx-swiper-dot:nth-of-type(n+2) { 34 margin-left: -10rpx; 35} 36 37.slide-image{ 38 width: 750rpx; 39 height: 280rpx; 40} 41.container .tab { 42 /* position: fixed; */ 43 /* top: 0; 44left: 0; */ 45 z-index: 9999 46} 47 48.container .movie { 49 display: block; 50 width: 700rpx; 51 margin: 20rpx auto; 52 background-color: #fff; 53 border-radius: 20rpx; 54 padding: 20rpx 55} 56 57.container .movie .movie-head { 58 display: flex; 59 width: 700rpx 60} 61 62.container .movie .movie-head .movie-title { 63 width: 350rpx; 64 text-align: left; 65 font-size: 30rpx; 66 font-weight: 700 67} 68 69.container .movie .movie-head .movie-count { 70 width: 310rpx; 71 text-align: right; 72 font-size: 24rpx 73} 74 75.container .movie .movie-list::-webkit-scrollbar { 76 display: none 77} 78 79.container .movie .movie-list { 80 display: block; 81 margin-top: 20rpx; 82 white-space: nowrap; 83 overflow-x: scroll 84} 85 86.container .movie .movie-list .item { 87 display: inline-block; 88 width: 170rpx; 89 margin-right: 10rpx 90} 91 92.container .movie .movie-list .item .cover { 93 display: blcok; 94 width: 160rpx; 95 height: 250rpx; 96 border-radius: 8rpx 97} 98 99.container .movie .movie-list .item .name { 100 font-size: 28rpx; 101 font-weight: 700; 102 width: 170rpx; 103 text-overflow: hidden; 104 white-space: nowrap 105} 106 107.container .movie .movie-list .item .buy { 108 width: 120rpx; 109 height: 54rpx; 110 line-height: 54rpx; 111 background-color: #d8d8d8; 112 border-radius: 40rpx; 113 color: #fff; 114 font-size: 26rpx; 115 text-align: center 116} 117 118.container .coupon { 119 padding-top: 0rpx; 120 padding-bottom: 10rpx 121} 122 123.container .coupon .item { 124 background-color: #fff; 125 margin: 30rpx; 126 border-radius: 10rpx; 127 padding: 0 30rpx 30rpx 30rpx 128} 129 130.container .coupon .item .top { 131 height: 116rpx; 132 display: flex; 133 align-items: center; 134 justify-content: space-between 135} 136 137.container .coupon .item .top .left { 138 height: 116rpx; 139 width: 440rpx; 140 display: flex; 141 align-items: center; 142 justify-content: space-between 143} 144 145.container .coupon .item .top .left .content { 146 width: 100% 147} 148 149.container .coupon .item .top .left .icon { 150 display: inline-block; 151 vertical-align: bottom; 152 width: 52rpx; 153 height: auto 154} 155 156.container .coupon .item .top .left .name { 157 text-align: left; 158 display: inline-block; 159 vertical-align: bottom; 160 font-size: 34rpx; 161 color: #000; 162 line-height: 50rpx; 163 font-weight: 700; 164 margin-left: 15rpx 165} 166 167.container .coupon .item .top .left .text { 168 width: 150rpx; 169 height: 38rpx; 170 line-height: 38rpx; 171 text-align: center; 172 font-size: 24rpx; 173 color: #61300e; 174 background: linear-gradient(90deg, #f9db8d, #f8d98a); 175 border-radius: 6rpx 176} 177 178.container .coupon .item .top .right { 179 width: 170rpx; 180 height: 60rpx; 181 border-radius: 30rpx; 182 background: linear-gradient(90deg, #ec6f43, #ea4a36); 183 color: #fff; 184 font-size: 28rpx; 185 line-height: 60rpx; 186 text-align: center 187} 188 189.container .coupon .item .bottom { 190 height: auto; 191 width: 100% 192} 193 194.container .coupon .item .bottom image { 195 display: block; 196 width: 100%; 197 height: auto 198}  一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 JS 脚本文件来处理用户的操作。为了实现云服务，云更新，应用微云免费笔记作为后台，通过post方式，读取数据，实现数据更新。\n 以 wx.request 为例：\n1wx.request({ 2 url: \u0026#39;https://share.weiyun.com/3rxFZygp\u0026#39;, 3 method: \u0026#34;POST\u0026#34;, 4 success(res) { 5 //【横幅图片】 6 var html = res.data 7 var banner = html.split(\u0026#34;【横幅图片】\u0026#34;)[2].replace(/\u0026amp;amp;/g,\u0026#34;\u0026amp;\u0026#34;) 8 console.log(\u0026#34;【横幅图片】中内容\u0026#34;, banner) 9 var gather = banner.split(\u0026#34;♑\u0026#34;); 10 console.log(\u0026#34;内容转换成集合\u0026#34;, gather) 11 that.imgUrls = that.imgUrls.concat(gather); 12 //【分类项目】 13 var html = res.data 14 var classify = html.split(\u0026#34;【分类项目】\u0026#34;)[1].replace(/\u0026amp;amp;/g,\u0026#34;\u0026amp;\u0026#34;) 15 console.log(\u0026#34;【分类项目】中内容\u0026#34;, classify) 16 if (classify != \u0026#34;\u0026#34;) { 17 var groups = classify.split(\u0026#34;间隔\u0026#34;); 18 for (var i = 0; i \u0026lt; groups.length; i++) { 19 console.log(\u0026#34;第\u0026#34;, i + 1, \u0026#34;个\u0026#34;) 20 var kinds = groups[i].split(\u0026#34;♑\u0026#34;); 21 console.log(\u0026#34;内容转换成集合\u0026#34;, kinds) 22 var object = { 23 icon: kinds[0], 24 text: kinds[1], 25 tabId: kinds[2], 26 }; 27 console.log(\u0026#34;集合转换成对象\u0026#34;, object) 28 that.tabs.push(object); 29 } 30 } 31 //【优惠券项目】 32 var html = res.data 33 var discount = html.split(\u0026#34;【优惠券项目】\u0026#34;)[1].replace(/\u0026amp;amp;/g,\u0026#34;\u0026amp;\u0026#34;) 34 console.log(\u0026#34;【优惠券项目】中内容\u0026#34;, discount) 35 if (discount != \u0026#34;\u0026#34;) { 36 var events = discount.split(\u0026#34;间隔\u0026#34;); 37 for (var i = 0; i \u0026lt; events.length; i++) { 38 console.log(\u0026#34;第\u0026#34;, i + 1, \u0026#34;个\u0026#34;) 39 var items = events[i].split(\u0026#34;♑\u0026#34;); 40 console.log(\u0026#34;内容转换成集合\u0026#34;, items) 41 var obj = { 42 bannerPic: items[0], 43 icon: items[1], 44 appid: items[2], 45 path: items[3], 46 name: items[4], 47 sort: items[5], 48 tabId: items[6], 49 type: items[7] 50 }; 51 console.log(\u0026#34;集合转换成对象\u0026#34;, obj) 52 that.coupons.push(obj); 53 } 54 } 55 } 56 })  本文小程序已上线微信官方，欢迎扫描查看。\n ","date":"2020-10-21","img":"","permalink":"/zh-cn/docs/wechat-applet/","series":["文档"],"tags":["微信"],"title":"微信小程序"},{"categories":["智能家居"],"content":"智能家居简介  智能家居是以住宅为平台，利用综合布线技术、网络通信技术、安全防范技术、自动控制技术、音视频技术将家居生活有关的设施集成，构建高效的住宅设施与家庭日程事务的管理系统，提升家居安全性、便利性、舒适性、艺术性，并实现环保节能的居住环境。\n项目实现  基于ESP8266、ESP32-CAM所开发设计智能家居设备，含温度检测，灯条控制，电脑LAN唤醒，智能摄像车等多个物联网智能家居项目，综合小爱同学，小度，天猫精灵等多平台适配。\n具体步骤  使用WiFi接入，当设备和手机在同一个局域网中，为局域网通信，其余情况，使用MQTT远程通信。\n Arduino IDE需安装好esp8266/esp32扩展\n Arduino IDE 1.8.7或更新版本\n 务必使用 3.0.0 或以上release版本的 ESP8266/esp32 Arduino package\n 1.PC的WOL唤醒，是通过UDP广播实现，配合主板实现网络唤醒开机，关机可以配合关机UDP广播实现，以 esp8266 为例：\n1#define BLINKER_WIFI 2#define BLINKER_MIOT_OUTLET 3 4#define BLINKER_DUEROS_OUTLET 5 6#define BLINKER_ALIGENIE_OUTLET 7 8//#define BLINKER_WITHOUT_SSL 9 10#include \u0026lt;Servo.h\u0026gt; 11#include \u0026lt;Blinker.h\u0026gt;12#include \u0026lt;WiFiUDP.h\u0026gt;13#include \u0026lt;ESP8266Ping.h\u0026gt;14 15char auth[] = \u0026#34;35a74dc36a92\u0026#34;; 16char ssid[] = \u0026#34;Sweet_meng\u0026#34;; 17char pswd[] = \u0026#34;aita0116.\u0026#34;; 18 19BlinkerButton Button1(\u0026#34;k1\u0026#34;); 20BlinkerSlider Slider1(\u0026#34;ser-num\u0026#34;); //实时位置 滑块 数据键名 范围1-180 21 22Servo myservo; 23int ser_num; 24//唤醒目标电脑的mac地址 25byte mac[] = {0x00, 0xE0, 0x70, 0x49, 0x1D, 0xE7}; 26byte preamble[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; 27//幻数据包需要在局域网中广播发送,要控制的电脑的网段的255地址 28IPAddress ip(192, 168, 0, 255); 29//建立一个WiFiUDP对象 UDP 30WiFiUDP UDP; 31//UDP接收地址，我这里是使用的广播，注意网段 32const char *UDPAddress = \u0026#34;192.168.0.108\u0026#34;; 33//UDP端口 34const int UDPPort = 7101; 35bool oState = false; 36 37void heartbeat() 38{ 39 BLINKER_LOG(\u0026#34;heartbeat,state: \u0026#34;, oState); 40 if (HIGH == oState) 41 { 42 Button1.print(\u0026#34;on\u0026#34;); 43 } 44 else 45 { 46 Button1.print(\u0026#34;off\u0026#34;); 47 } 48} 49 50void button1_callback(const String \u0026amp;state) 51{ 52 BLINKER_LOG(\u0026#34;get button state: \u0026#34;, state); 53 if (state == BLINKER_CMD_ON) 54 { 55 BLINKER_LOG(\u0026#34;Toggle on!\u0026#34;); 56 UDP.beginPacket(ip, 9); //UDP发送到目标（IP，端口） 57 UDP.write(preamble, sizeof preamble); //写入包头(FF,FF,FF,FF,FF,FF) 58 for (byte i = 0; i \u0026lt; 16; i++) 59 { 60 UDP.write(mac, sizeof mac); 61 } 62 BLINKER_LOG(\u0026#34;唤醒主机\u0026#34;); 63 UDP.endPacket(); 64 Button1.print(\u0026#34;on\u0026#34;); 65 oState = true; 66 } 67 else if (state == BLINKER_CMD_OFF) 68 { 69 BLINKER_LOG(\u0026#34;Toggle off!\u0026#34;); 70 char sd[] = \u0026#34;shut\u0026#34;; //与电脑相对应的指令 71 UDP.beginPacket(UDPAddress, UDPPort); //准备发送，设置地址和端口 72 UDP.write((char *)sd, 8); 73 BLINKER_LOG(\u0026#34;关闭主机\u0026#34;); 74 UDP.endPacket(); 75 Button1.print(\u0026#34;off\u0026#34;); 76 oState = false; 77 } 78 BlinkerMIOT.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 79 BlinkerMIOT.print(); 80 81 BlinkerDuerOS.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 82 BlinkerDuerOS.print(); 83 84 BlinkerAliGenie.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 85 BlinkerAliGenie.print(); 86} 87 88void slider1_callback(int32_t value) 89{ 90 ser_num = value; 91 myservo.write(ser_num); 92 Blinker.delay(500); 93 BLINKER_LOG(\u0026#34;get slider value: \u0026#34;, value); 94} 95 96void miotPowerState(const String \u0026amp;state) 97{ 98 BLINKER_LOG(\u0026#34;need set power state: \u0026#34;, state); 99 if (state == BLINKER_CMD_ON) 100 { 101 UDP.beginPacket(ip, 9); //UDP发送到目标（IP，端口） 102 UDP.write(preamble, sizeof preamble); //写入包头(FF,FF,FF,FF,FF,FF) 103 for (byte i = 0; i \u0026lt; 16; i++) 104 { 105 UDP.write(mac, sizeof mac); 106 } 107 BLINKER_LOG(\u0026#34;唤醒主机\u0026#34;); 108 UDP.endPacket(); 109 oState = true; 110 } 111 else if (state == BLINKER_CMD_OFF) 112 { 113 char sd[] = \u0026#34;shut\u0026#34;; //与电脑相对应的指令 114 UDP.beginPacket(UDPAddress, UDPPort); //准备发送，设置地址和端口 115 UDP.write((char *)sd, 8); 116 BLINKER_LOG(\u0026#34;关闭主机\u0026#34;); 117 UDP.endPacket(); 118 oState = false; 119 } 120 BlinkerMIOT.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 121 BlinkerMIOT.print(); 122} 123 124void miotQuery(int32_t queryCode) 125{ 126 BLINKER_LOG(\u0026#34;MIOT Query codes: \u0026#34;, queryCode); 127 switch (queryCode) 128 { 129 case BLINKER_CMD_QUERY_ALL_NUMBER: 130 BLINKER_LOG(\u0026#34;MIOT Query All\u0026#34;); 131 BlinkerMIOT.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 132 BlinkerMIOT.print(); 133 break; 134 case BLINKER_CMD_QUERY_POWERSTATE_NUMBER: 135 BLINKER_LOG(\u0026#34;MIOT Query Power State\u0026#34;); 136 BlinkerMIOT.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 137 BlinkerMIOT.print(); 138 break; 139 default: 140 BlinkerMIOT.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 141 BlinkerMIOT.print(); 142 break; 143 } 144} 145 146void duerPowerState(const String \u0026amp;state) 147{ 148 BLINKER_LOG(\u0026#34;need set power state: \u0026#34;, state); 149 if (state == BLINKER_CMD_ON) 150 { 151 UDP.beginPacket(ip, 9); //UDP发送到目标（IP，端口） 152 UDP.write(preamble, sizeof preamble); //写入包头(FF,FF,FF,FF,FF,FF) 153 for (byte i = 0; i \u0026lt; 16; i++) 154 { 155 UDP.write(mac, sizeof mac); 156 } 157 BLINKER_LOG(\u0026#34;唤醒主机\u0026#34;); 158 UDP.endPacket(); 159 oState = true; 160 } 161 else if (state == BLINKER_CMD_OFF) 162 { 163 char sd[] = \u0026#34;shut\u0026#34;; //与电脑相对应的指令 164 UDP.beginPacket(UDPAddress, UDPPort); //准备发送，设置地址和端口 165 UDP.write((char *)sd, 8); 166 BLINKER_LOG(\u0026#34;关闭主机\u0026#34;); 167 UDP.endPacket(); 168 oState = false; 169 } 170 BlinkerDuerOS.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 171 BlinkerDuerOS.print(); 172} 173 174void duerQuery(int32_t queryCode) 175{ 176 BLINKER_LOG(\u0026#34;DuerOS Query codes: \u0026#34;, queryCode); 177 switch (queryCode) 178 { 179 case BLINKER_CMD_QUERY_ALL_NUMBER: 180 BLINKER_LOG(\u0026#34;DuerOS Query All\u0026#34;); 181 BlinkerDuerOS.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 182 BlinkerDuerOS.time(millis()); 183 BlinkerDuerOS.print(); 184 break; 185 case BLINKER_CMD_QUERY_POWERSTATE_NUMBER: 186 BLINKER_LOG(\u0026#34;DuerOS Query Power State\u0026#34;); 187 BlinkerDuerOS.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 188 BlinkerDuerOS.print(); 189 break; 190 case BLINKER_CMD_QUERY_TIME_NUMBER: 191 BLINKER_LOG(\u0026#34;DuerOS Query time\u0026#34;); 192 BlinkerDuerOS.time(millis()); 193 BlinkerDuerOS.print(); 194 break; 195 default: 196 BlinkerDuerOS.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 197 BlinkerDuerOS.time(millis()); 198 BlinkerDuerOS.print(); 199 break; 200 } 201} 202 203void aligeniePowerState(const String \u0026amp;state) 204{ 205 BLINKER_LOG(\u0026#34;need set power state: \u0026#34;, state); 206 if (state == BLINKER_CMD_ON) 207 { 208 UDP.beginPacket(ip, 9); //UDP发送到目标（IP，端口） 209 UDP.write(preamble, sizeof preamble); //写入包头(FF,FF,FF,FF,FF,FF) 210 for (byte i = 0; i \u0026lt; 16; i++) 211 { 212 UDP.write(mac, sizeof mac); 213 } 214 BLINKER_LOG(\u0026#34;唤醒主机\u0026#34;); 215 UDP.endPacket(); 216 oState = true; 217 } 218 else if (state == BLINKER_CMD_OFF) 219 { 220 char sd[] = \u0026#34;shut\u0026#34;; //与电脑相对应的指令 221 UDP.beginPacket(UDPAddress, UDPPort); //准备发送，设置地址和端口 222 UDP.write((char *)sd, 8); 223 BLINKER_LOG(\u0026#34;关闭主机\u0026#34;); 224 UDP.endPacket(); 225 oState = false; 226 } 227 BlinkerAliGenie.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 228 BlinkerAliGenie.print(); 229} 230 231void aligenieQuery(int32_t queryCode) 232{ 233 BLINKER_LOG(\u0026#34;AliGenie Query codes: \u0026#34;, queryCode); 234 switch (queryCode) 235 { 236 case BLINKER_CMD_QUERY_ALL_NUMBER: 237 BLINKER_LOG(\u0026#34;AliGenie Query All\u0026#34;); 238 BlinkerAliGenie.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 239 BlinkerAliGenie.print(); 240 break; 241 case BLINKER_CMD_QUERY_POWERSTATE_NUMBER: 242 BLINKER_LOG(\u0026#34;AliGenie Query Power State\u0026#34;); 243 BlinkerAliGenie.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 244 BlinkerAliGenie.print(); 245 break; 246 default: 247 BlinkerAliGenie.powerState(oState ? \u0026#34;on\u0026#34; : \u0026#34;off\u0026#34;); 248 BlinkerAliGenie.print(); 249 break; 250 } 251} 252 253void dataRead(const String \u0026amp;data) 254{ 255 BLINKER_LOG(\u0026#34;Blinker readString: \u0026#34;, data); 256 Blinker.vibrate(); 257 uint32_t BlinkerTime = millis(); 258 Blinker.print(\u0026#34;millis\u0026#34;, BlinkerTime); 259} 260 261void setup() 262{ 263 Serial.begin(115200); 264 BLINKER_DEBUG.stream(Serial); 265 // BLINKER_DEBUG.debugAll(); 266 267 myservo.attach(0); //servo.attach():设置舵机数据引脚 268 myservo.write(90); //servo.write():设置转动角度 269 270 Button1.attach(button1_callback); 271 Slider1.attach(slider1_callback); 272 Blinker.attachHeartbeat(heartbeat); 273 274 Blinker.begin(auth, ssid, pswd); 275 Blinker.attachData(dataRead); 276 277 BlinkerMIOT.attachPowerState(miotPowerState); 278 BlinkerMIOT.attachQuery(miotQuery); 279 280 BlinkerDuerOS.attachPowerState(duerPowerState); 281 BlinkerDuerOS.attachQuery(duerQuery); 282 283 BlinkerAliGenie.attachPowerState(aligeniePowerState); 284 BlinkerAliGenie.attachQuery(aligenieQuery); 285} 286 287void loop() 288{ 289 Blinker.run(); 290}  2.WS2812的灯带，配合FastLED库，可以配合实现多种灯光效果，以 esp8266 为例：\n1///////////////////////////////////////////////////////////////////////////K1灯效FastLED(依赖K2灯效FastLED) 2 3typedef void (*SimplePatternList1[])(); 4SimplePatternList1 gPatterns1 = {rainbow}; //rainbow, rainbowWithGlitter, confetti, sinelon, juggle, bpm 6种特效切换 5 6///////////////////////////////////////////////////////////////////////////K2灯效FastLED 7// List of patterns to cycle through. Each is defined as a separate function below. 8typedef void (*SimplePatternList[])(); 9SimplePatternList gPatterns = {juggle}; //rainbow, rainbowWithGlitter, confetti, sinelon, juggle, bpm 6种特效切换 10 11uint8_t gCurrentPatternNumber = 0; // Index number of which pattern is current 12uint8_t gHue = 0; // rotating \u0026#34;base color\u0026#34; used by many of the patterns 13 14#define ARRAY_SIZE(A) (sizeof(A) / sizeof((A)[0])) 15 16void nextPattern() 17{ 18 // add one to the current pattern number, and wrap around at the end 19 gCurrentPatternNumber = (gCurrentPatternNumber + 1) % ARRAY_SIZE(gPatterns); 20} 21 22void rainbow() 23{ 24 // FastLED\u0026#39;s built-in rainbow generator 25 fill_rainbow(leds, NUM_LEDS, gHue, 3); 26} 27 28void rainbowWithGlitter() 29{ 30 // built-in FastLED rainbow, plus some random sparkly glitter 31 rainbow(); 32 addGlitter(80); 33} 34 35void addGlitter(fract8 chanceOfGlitter) 36{ 37 if (random8() \u0026lt; chanceOfGlitter) 38 { 39 leds[random16(NUM_LEDS)] += CRGB::White; 40 } 41} 42 43void confetti() 44{ 45 // random colored speckles that blink in and fade smoothly 46 fadeToBlackBy(leds, NUM_LEDS, 10); 47 int pos = random16(NUM_LEDS); 48 leds[pos] += CHSV(gHue + random8(64), 200, 255); 49} 50 51void sinelon() 52{ 53 // a colored dot sweeping back and forth, with fading trails 54 fadeToBlackBy(leds, NUM_LEDS, 20); 55 int pos = beatsin16(13, 0, NUM_LEDS - 1); 56 leds[pos] += CHSV(gHue, 255, 192); 57} 58 59void bpm() 60{ 61 // colored stripes pulsing at a defined Beats-Per-Minute (BPM) 62 uint8_t BeatsPerMinute = 62; 63 CRGBPalette16 palette = PartyColors_p; 64 uint8_t beat = beatsin8(BeatsPerMinute, 64, 255); 65 for (int i = 0; i \u0026lt; NUM_LEDS; i++) 66 { //9948 67 leds[i] = ColorFromPalette(palette, gHue + (i * 2), beat - gHue + (i * 10)); 68 } 69} 70 71void juggle() 72{ 73 // eight colored dots, weaving in and out of sync with each other 74 fadeToBlackBy(leds, NUM_LEDS, 20); 75 byte dothue = 0; 76 for (int i = 0; i \u0026lt; 8; i++) 77 { 78 leds[beatsin16(i + 7, 0, NUM_LEDS - 1)] |= CHSV(dothue, 200, 255); 79 dothue += 32; 80 } 81} 82 83///////////////////////////////////////////////////////////////////////////K3灯效 84//冷却：空气上升时会冷却多少？ 85//冷却少=火焰高。 冷却更多=火焰更短。 86//默认值50，建议范围20-100 87#define COOLING 50 88 89//发出火花：有什么机会（总共255个）点燃新的火花？ 90//更高的机会=更多的怒吼。 机会降低=火势更加闪烁。 91//默认值为120，建议范围为50-200。 92#define SPARKING 120 93bool gReverseDirection = false; 94void Fire2012() 95{ 96 // Array of temperature readings at each simulation cell 97 static byte heat[NUM_LEDS]; 98 99 // Step 1. Cool down every cell a little 100 for (int i = 0; i \u0026lt; NUM_LEDS; i++) 101 { 102 heat[i] = qsub8(heat[i], random8(0, ((COOLING * 10) / NUM_LEDS) + 2)); 103 } 104 105 // Step 2. Heat from each cell drifts \u0026#39;up\u0026#39; and diffuses a little 106 for (int k = NUM_LEDS - 1; k \u0026gt;= 2; k--) 107 { 108 heat[k] = (heat[k - 1] + heat[k - 2] + heat[k - 2]) / 3; 109 } 110 111 // Step 3. Randomly ignite new \u0026#39;sparks\u0026#39; of heat near the bottom 112 if (random8() \u0026lt; SPARKING) 113 { 114 int y = random8(7); 115 heat[y] = qadd8(heat[y], random8(160, 255)); 116 } 117 118 // Step 4. Map from heat cells to LED colors 119 for (int j = 0; j \u0026lt; NUM_LEDS; j++) 120 { 121 CRGB color = HeatColor(heat[j]); 122 int pixelnumber; 123 if (gReverseDirection) 124 { 125 pixelnumber = (NUM_LEDS - 1) - j; 126 } 127 else 128 { 129 pixelnumber = j; 130 } 131 leds[pixelnumber] = color; 132 } 133} 134 135///////////////////////////////////////////////////////////////////////////K4灯效 136#if FASTLED_VERSION \u0026lt; 3001000 137#error \u0026#34;Requires FastLED 3.1 or later; check github for latest code.\u0026#34; 138#endif 139// This function draws rainbows with an ever-changing, 140// widely-varying set of parameters. 141void pride() 142{ 143 static uint16_t sPseudotime = 0; 144 static uint16_t sLastMillis = 0; 145 static uint16_t sHue16 = 0; 146 147 uint8_t sat8 = beatsin88(87, 220, 250); 148 uint8_t brightdepth = beatsin88(341, 96, 224); 149 uint16_t brightnessthetainc16 = beatsin88(203, (25 * 256), (40 * 256)); 150 uint8_t msmultiplier = beatsin88(147, 23, 60); 151 152 uint16_t hue16 = sHue16; //gHue * 256; 153 uint16_t hueinc16 = beatsin88(113, 1, 3000); 154 155 uint16_t ms = millis(); 156 uint16_t deltams = ms - sLastMillis; 157 sLastMillis = ms; 158 sPseudotime += deltams * msmultiplier; 159 sHue16 += deltams * beatsin88(400, 5, 9); 160 uint16_t brightnesstheta16 = sPseudotime; 161 162 for (uint16_t i = 0; i \u0026lt; NUM_LEDS; i++) 163 { 164 hue16 += hueinc16; 165 uint8_t hue8 = hue16 / 256; 166 167 brightnesstheta16 += brightnessthetainc16; 168 uint16_t b16 = sin16(brightnesstheta16) + 32768; 169 170 uint16_t bri16 = (uint32_t)((uint32_t)b16 * (uint32_t)b16) / 65536; 171 uint8_t bri8 = (uint32_t)(((uint32_t)bri16) * brightdepth) / 65536; 172 bri8 += (255 - brightdepth); 173 174 CRGB newcolor = CHSV(hue8, sat8, bri8); 175 176 uint16_t pixelnumber = i; 177 pixelnumber = (NUM_LEDS - 1) - pixelnumber; 178 179 nblend(leds[pixelnumber], newcolor, 64); 180 } 181} 182void mode_2() 183{ 184 if (BRIGHTNESS \u0026lt; 20) 185 { 186 BRIGHTNESS = 20; 187 Slider1.print(BRIGHTNESS); 188 } 189 FastLED.setBrightness(BRIGHTNESS); //实时更新亮度 190 gPatterns1[gCurrentPatternNumber](); 191 FastLED.show(); 192 FastLED.delay(200 / UPDATES_PER_SECOND); 193 EVERY_N_MILLISECONDS(20) { gHue++; } // slowly cycle the \u0026#34;base color\u0026#34; through the rainbow 194 EVERY_N_SECONDS(10) { nextPattern(); } // change patterns periodically 195} 196 197void mode_3() 198{ 199 if (BRIGHTNESS \u0026lt; 20) 200 { 201 BRIGHTNESS = 20; 202 Slider1.print(BRIGHTNESS); 203 } 204 FastLED.setBrightness(BRIGHTNESS); //实时更新亮度 205 gPatterns[gCurrentPatternNumber](); 206 FastLED.show(); 207 FastLED.delay(1000 / (UPDATES_PER_SECOND / 10)); 208 209 // do some periodic updates 210 EVERY_N_MILLISECONDS(20) { gHue++; } // slowly cycle the \u0026#34;base color\u0026#34; through the rainbow 211 EVERY_N_SECONDS(10) { nextPattern(); } // change patterns periodically 212} 213 214void mode_4() 215{ 216 if (BRIGHTNESS \u0026lt; 20) 217 { 218 BRIGHTNESS = 20; 219 Slider1.print(BRIGHTNESS); 220 } 221 Fire2012(); 222 FastLED.setBrightness(BRIGHTNESS); //实时更新亮度 223 FastLED.delay(1000 / UPDATES_PER_SECOND); 224} 225 226void mode_5() 227{ 228 if (BRIGHTNESS \u0026lt; 20) 229 { 230 BRIGHTNESS = 20; 231 Slider1.print(BRIGHTNESS); 232 } 233 FastLED.setBrightness(BRIGHTNESS); //实时更新亮度 234 pride(); 235 FastLED.show(); 236 FastLED.delay(1000 / (UPDATES_PER_SECOND / 5)); 237} 238  3.ESP32-CAM带有一个摄像头，可以搭建一个视频监控车，ESP32-CAM底座原理图和PCB，以及小车底座PCB如下：\n    以 esp32 为例：\n1int calculatePWM(int degree) //舵机角度 2{ 3 //20ms周期，高电平0.5-2.5ms，对应0-180度角度 4 const float deadZone = 6.4; //对应0.5ms（0.5ms/(20ms/256）) 5 const float max = 32; //对应2.5ms 6 if (degree \u0026lt; 0) 7 degree = 0; 8 if (degree \u0026gt; 180) 9 degree = 180; 10 return (int)(((max - deadZone) / 180) * degree + deadZone); 11} 12 13void servo_360() //360度舵机控制 14{ 15 if (y \u0026lt; 128) 16 { 17 ledcWrite(servo_channel, calculatePWM(88)); // 输出PWM 18 } 19 else if (y == 128) 20 { 21 ledcWrite(servo_channel, calculatePWM(92)); // 输出PWM 22 } 23 else if (y \u0026gt; 128) 24 { 25 ledcWrite(servo_channel, calculatePWM(96)); // 输出PWM 26 } 27} 28 29void xunhuan() 30{ 31 ledcWrite(servo_channel, calculatePWM(angle)); // 输出PWM 32 ledcWrite(flashled_channel, flashled_pwm); // 输出PWM 33 if ((y \u0026lt;= 37.5) \u0026amp;\u0026amp; (x \u0026gt;= 37.5) \u0026amp;\u0026amp; (x \u0026lt;= 217.5))//前进 34 { 35 ledcWrite(motorA1_channel, motor_pwm); 36 ledcWrite(motorA2_channel, 0); 37 ledcWrite(motorB1_channel, motor_pwm); 38 ledcWrite(motorB2_channel, 0); 39 } 40 if ((x \u0026lt;= 37.5) \u0026amp;\u0026amp; (y \u0026gt;= 37.5) \u0026amp;\u0026amp; (y \u0026lt;= 217.5))//左转 41 { 42 ledcWrite(motorA1_channel, 0); 43 ledcWrite(motorA2_channel, motor_pwm); 44 ledcWrite(motorB1_channel, motor_pwm); 45 ledcWrite(motorB2_channel, 0); 46 } 47 if ((x \u0026gt;= 217.5) \u0026amp;\u0026amp; (y \u0026gt;= 37.5) \u0026amp;\u0026amp; (y \u0026lt;= 217.5))//右转 48 { 49 ledcWrite(motorA1_channel, motor_pwm); 50 ledcWrite(motorA2_channel, 0); 51 ledcWrite(motorB1_channel, 0); 52 ledcWrite(motorB2_channel, motor_pwm); 53 } 54 if ((y \u0026gt;= 217.5) \u0026amp;\u0026amp; (x \u0026gt;= 37.5) \u0026amp;\u0026amp; (x \u0026lt;= 217.5))//后退 55 { 56 ledcWrite(motorA1_channel, 0); 57 ledcWrite(motorA2_channel, motor_pwm); 58 ledcWrite(motorB1_channel, 0); 59 ledcWrite(motorB2_channel, motor_pwm); 60 } 61 if ((x \u0026gt; 37.5) \u0026amp;\u0026amp; (x \u0026lt; 217.5) \u0026amp;\u0026amp; (y \u0026gt; 37.5) \u0026amp;\u0026amp; (y \u0026lt; 217.5))//后退 62 { 63 ledcWrite(motorA1_channel, 0); 64 ledcWrite(motorA2_channel, 0); 65 ledcWrite(motorB1_channel, 0); 66 ledcWrite(motorB2_channel, 0); 67 } 68}  本文相关项目完整源码已上传本人gitee，点击查看更多智能家居项目源码，如智能风扇，智能空调，智能插座等等。\n","date":"2020-05-19","img":"","permalink":"/zh-cn/docs/smart-home/","series":["文档"],"tags":["智能家居"],"title":"智能家居"},{"categories":["测试工装"],"content":"测试工装简介  所谓测试工装,是用来检验产品是否达到预期指数期望的设备。当产品不合格时,测试工装会有相应的反应。\n项目实现  通过代码，最大程度的简化测试PCBA板子的难度，用于产线功能调测，降低产线的测试难度。\n具体步骤  根据实际板子实现功能，设计对应工装实现效果。\n 以 测试工装外观 为例：\n  更多详细工完整源码已上传本人gitee，点击查看。\n","date":"2019-11-12","img":"","permalink":"/zh-cn/docs/test-tooling/","series":["文档"],"tags":["工装"],"title":"测试工装"},{"categories":["新唐项目-霍尔感应"],"content":"项目简介  基于新唐芯片MS51FB9AE芯片设计T16机种旋钮开光PCB，并编写其对应对应旋钮功能程序。\n项目实现  通过新唐芯片MS51FB9AE芯片，结合AD实现旋转板PCB绘制，结合霍尔感应元件，实现旋钮功能。\n具体步骤  通过IC规格书，设计对应IO控制对应功能，以 原理图 为例：\n  以 PCB图 为例：\n  本文完整原理图PCB文件已上传本人gitee，点击查看。\n","date":"2019-07-18","img":"","permalink":"/zh-cn/docs/xintang-project-hall-induction/","series":["文档"],"tags":["新唐"],"title":"新唐项目-霍尔感应"},{"categories":["新唐项目-数码显示"],"content":"项目简介  基于新唐芯片MS51FB9AE芯片设计T10机种视窗板原理图PCB，并编写其对应数码显示功能程序。\n项目实现  通过新唐芯片MS51FB9AE芯片，结合AD实现视窗板PCB绘制，结合数码管，实现数码显示功能。\n具体步骤  通过IC规格书，设计对应IO控制对应功能，以 原理图 为例：\n  以 PCB图 为例：\n  以 数码管扫描 为例：\n1void SegDisplay(u8 Num) 2{ 3 switch(Num) 4 { 5 case 0: 6 SEG_A=0; 7 SEG_B=0; 8 SEG_C=0; 9 SEG_D=0; 10 SEG_E=0; 11 SEG_F=0; 12 SEG_G=1; 13 SEG_DOT=0; 14 break; 15 case 1: 16 SEG_A=1; 17 SEG_B=0; 18 SEG_C=0; 19 SEG_D=1; 20 SEG_E=1; 21 SEG_F=1; 22 SEG_G=1; 23 SEG_DOT=0; 24 break; 25 case 2: 26 SEG_A=0; 27 SEG_B=0; 28 SEG_C=1; 29 SEG_D=0; 30 SEG_E=0; 31 SEG_F=1; 32 SEG_G=0; 33 SEG_DOT=0; 34 break; 35 case 3: 36 SEG_A=0; 37 SEG_B=0; 38 SEG_C=0; 39 SEG_D=0; 40 SEG_E=1; 41 SEG_F=1; 42 SEG_G=0; 43 SEG_DOT=0; 44 break; 45 case 4: 46 SEG_A=1; 47 SEG_B=0; 48 SEG_C=0; 49 SEG_D=1; 50 SEG_E=1; 51 SEG_F=0; 52 SEG_G=0; 53 SEG_DOT=0; 54 break; 55 case 5: 56 SEG_A=0; 57 SEG_B=1; 58 SEG_C=0; 59 SEG_D=0; 60 SEG_E=1; 61 SEG_F=0; 62 SEG_G=0; 63 SEG_DOT=0; 64 break; 65 case 6: 66 SEG_A=0; 67 SEG_B=1; 68 SEG_C=0; 69 SEG_D=0; 70 SEG_E=0; 71 SEG_F=0; 72 SEG_G=0; 73 SEG_DOT=0; 74 break; 75 case 7: 76 SEG_A=0; 77 SEG_B=0; 78 SEG_C=0; 79 SEG_D=1; 80 SEG_E=1; 81 SEG_F=1; 82 SEG_G=1; 83 SEG_DOT=0; 84 break; 85 case 8: 86 SEG_A=0; 87 SEG_B=0; 88 SEG_C=0; 89 SEG_D=0; 90 SEG_E=0; 91 SEG_F=0; 92 SEG_G=0; 93 SEG_DOT=0; 94 break; 95 case 9: 96 SEG_A=0; 97 SEG_B=0; 98 SEG_C=0; 99 SEG_D=0; 100 SEG_E=1; 101 SEG_F=0; 102 SEG_G=0; 103 SEG_DOT=0; 104 break; 105 case 0x0a: //\u0026#34;NULL\u0026#34; 106 SEG_A=1; 107 SEG_B=1; 108 SEG_C=1; 109 SEG_D=1; 110 SEG_E=1; 111 SEG_F=1; 112 SEG_G=1; 113 SEG_DOT=1; 114 break; 115 default: //\u0026#34;--\u0026#34; 116 SEG_A=1; 117 SEG_B=1; 118 SEG_C=1; 119 SEG_D=1; 120 SEG_E=1; 121 SEG_F=1; 122 SEG_G=0; 123 SEG_DOT=0; 124 break; 125 } 126} 127 128 129void SegScan(void) 130{ 131 MODEL_A=1; 132 SEAT_A1=1; 133 SEAT_A2=1; 134 WATER_A1=1; 135 WATER_A2=1; 136 if(LED_DC_BATTERY) 137 { 138 //_enadc=0; //close the ad 139 Flag_DC_Battery=1; //close the seg 140 } 141 else 142 { 143 //_enadc=1; //open the ad 144 Flag_DC_Battery=0; //open the seg 145 } 146 147 if((Temp_Seat_Value_H==0)\u0026amp;\u0026amp;(Temp_Seat_Value_L==0)\u0026amp;\u0026amp;(Temp_Seat_Value_H==0)\u0026amp;\u0026amp;(Temp_Seat_Value_L==0)\u0026amp;\u0026amp;(Mode==0)) 148 { 149 Temp_Water_Value_H=8; 150 Temp_Water_Value_L=8; 151 Temp_Seat_Value_H=8; 152 Temp_Seat_Value_L=8; 153 Mode=0x7f; 154 } 155 156 if((Temp_Water_Value_H==0)\u0026amp;\u0026amp;(Temp_Water_Value_L==0)) 157 { 158 Temp_Water_Value_H=0x0b; 159 Temp_Water_Value_L=0x0b; 160 } 161 162 if(((Temp_Seat_Value_H==0)\u0026amp;\u0026amp;(Temp_Seat_Value_L==2))||((Temp_Seat_Value_H==0)\u0026amp;\u0026amp;(Temp_Seat_Value_L==0))) 163 { 164 Temp_Seat_Value_H=0x0b; 165 Temp_Seat_Value_L=0x0b; 166 } 167 168 i++; 169 if(Flag_DC_Battery==0) 170 { 171 Water_Value_H=Temp_Water_Value_H; 172 Water_Value_L=Temp_Water_Value_L; 173 Seat_Value_H=Temp_Seat_Value_H; 174 Seat_Value_L=Temp_Seat_Value_L; 175 Mode \u0026amp;= 0xFF; 176 } 177 else 178 { 179 Water_Value_H=0x0a; 180 Water_Value_L=0x0a; 181 Seat_Value_H=0x0a; 182 Seat_Value_L=0x0a; 183 Mode \u0026amp;= 0x81; 184 } 185 186 switch(i) 187 { 188 case 1: 189 MODEL_A=1; 190 SegDisplay(Water_Value_H); 191 WATER_A1=0; 192 break; 193 case 2: 194 WATER_A1=1; 195 SegDisplay(Water_Value_L); 196 WATER_A2=0; 197 break; 198 case 3: 199 WATER_A2=1; 200 SegDisplay(Seat_Value_H); 201 SEAT_A1=0; 202 break; 203 case 4: 204 SEAT_A1=1; 205 SegDisplay(Seat_Value_L); 206 SEAT_A2=0; 207 break; 208 case 5: 209 SEAT_A2=1; 210 //SEG_A=0; 211 //SEG_B=0; 212 //SEG_C=0; 213 //SEG_D=0; 214 //SEG_E=0; 215 //SEG_F=0; 216 //SEG_G=0; 217 MODEL_A=0; 218 i=0; 219 default: 220 break; 221 } 222}  本文完整源码已上传本人gitee，点击查看。\n","date":"2019-03-26","img":"","permalink":"/zh-cn/docs/xintang-project-digital-display/","series":["文档"],"tags":["新唐"],"title":"新唐项目-数码显示"},{"categories":["合泰项目"],"content":"项目简介  基于合泰芯片BS84B08A-3触摸芯片设计T10机种泡沫盾板原理图PCB，并编写其对应触摸功能程序。\n项目实现  通过合泰芯片BS84B08A-3触摸芯片，结合AD实现触摸板PCB绘制，结合外设空气泵，实现喷泡沫功能。\n具体步骤  通过IC规格书，以及PCB触摸覆铜注意事项，设计对应IO控制对应功能，以 原理图 为例：\n  以 控制空气泵 为例：\n1#include \u0026#34;USER_PROGRAM.H\u0026#34; 2#include \u0026#34;BaseRef.H\u0026#34;3//#define LPump_2ndOpen 120-30 //药泵第二次加药时间 4//#define LPump_3rdOpen 120-60 //药泵第三次加药时间 5//#define LPump_4thOpen 120-90 //药泵第四次加药时间 6//#define LPump_5Open (15000-12000)/2 //药泵第五次加药时间 7#define LPump_1stOpen 7//80/10 //药泵第一次加药时间 8#define LPumpOpenTime 9//100/10 //药泵每次加药时间 9#define LPumpTimes 1 //药泵第每次加药次数 10#define LPumpColseTime 1//2/2 //药泵两次小加药时间间隔 11#define AirTime 50//500/10 //结束时吹气时间 12#define IntervalTime 250//2500/10 //吸药间隔时间 13#define FoamTimesLeft 210//70*3 //吸药次数剩余 14 15u8 FoamTime; //泡沫盾总时间 16//u16 CNT_LedFlicker; 17void FOAMCONTROL() 18{ 19/* 20if(Flag_FoamFirstOn==0) 21{ 22Flag_FoamFirstOn=1; //只进一次 23CNT_LPumpOpenTime=15; //赋予吸药时间 24CNT_LPumpTimes=1; //赋予吸药次数 25} 26*/ 27 if(FoamTime\u0026gt;0\u0026amp;\u0026amp;FoamTime\u0026lt;250) 28 { 29 CNT_1S=0; 30 APump=1; 31 if(CNT_FoamTime==0) 32 { 33 CNT_LPumpOpenTime=LPump_1stOpen+CPS_LpumpTime; //赋予吸药时间 34 CNT_LPumpTimes=LPumpTimes; //赋予吸药次数 35 CPS_LpumpTime=0; 36 CNT_FoamTime=IntervalTime; 37 38 } 39 if(CNT_FoamTime\u0026gt;0) 40 CNT_FoamTime--; 41 if(CNT_FoamTime==0) 42 { 43 CNT_LPumpOpenTime=LPumpOpenTime; //赋予吸药时间 44 CNT_LPumpTimes=LPumpTimes; //赋予吸药次数 45 CNT_FoamTime=IntervalTime; 46 } 47 // if(FoamTime==1) CNT_APumpTime=AirTime; //赋予空气泵开启时间，用于吹出管中残余水 48 } 49 else 50 { 51 /* 52if(CNT_APumpTime\u0026gt;0) 53{ 54CNT_APumpTime--; 55APump=1; 56} 57else 58*/ 59 // { 60 APump=0; 61 CNT_FoamTime=0; 62 // } 63 } 64 LPumpControl(); 65} 66 67//液泵控制 68void LPumpControl() 69{ 70 if(CNT_LPumpTimes\u0026gt;0) 71 { 72 /* 73if(CNT_LPumpOpenTime\u0026gt;LPumpColseTime) 74else 75{ 76LPump=0; 77Flag_ADService=0; 78} 79*/ 80 LPump=1; 81 if(CNT_LPumpOpenTime==LPumpOpenTime-2) //开启AD，检测电流 82 { 83 Flag_ADService=1; 84 AD_COUNT=0; 85 AD_SUM=0; 86 } 87 CNT_LPumpOpenTime--; 88 if(CNT_LPumpOpenTime==0) 89 { 90 if(CNT_LPumpTimes\u0026gt;1) CNT_LPumpOpenTime=LPumpOpenTime; 91 CNT_LPumpTimes--; 92 if(Flag_FloatKeyDown) 93 { 94 if(CNT_FoamTimesLeft\u0026lt;FoamTimesLeft) 95 CNT_FoamTimesLeft++; 96 else 97 Flag_LiquidLow=1; 98 } 99 else 100 { 101 CNT_FoamTimesLeft=0; 102 Flag_LiquidLow=0; 103 } 104 } 105 } 106 else 107 { 108 LPump=0; 109 CNT_LPumpOpenTime=0; 110 CNT_LPumpTimes=0; 111 } 112}  以 触摸控制 为例：\n1#include \u0026#34;USER_PROGRAM.H\u0026#34; 2#include \u0026#34;BaseRef.H\u0026#34;3 4u8 Touch_ok; //按键输出值 5 6union Fbit KeyFlag; //按键程序相关标志位 7#define Flag_First_Check KeyFlag.Flag.b0 8#define Flag_Get_Baseline KeyFlag.Flag.b1 9//------------------------------------------------------------------------------------- 10u16 BaseLine; //基线值 11u16 Value_Touch_Key_Old,Value_Touch_Key_New,Temp_Value_Touch_Key; 12u16 TimesCNT_Baseline;//,Times_Leg_In; 13 14Longword Temp_Count_Touch_Key; 15 16#define Para_Baseline_Tolerance 2 //公差 17#define Gap_Leg_In 4 18 19#define Times_Gap_Leg_In_Short 5 20#define Times_Gap_Leg_In_Long 200 21#define Times_Gap_Leg_Out 3 22 23#define Para_TimesCNT_Baseline_First_ON 256 24#define Para_TimesCNT_Baseline 1000 25 26Byte Key_Value,Key_Old,Key_Ok,Key_Status,Key_Mid; 27Word Key_CNT; 28Word Key_CNT_Pressed; 29Byte Key_CNT_Off; 30#define Key_Handled Key_Status,B(0) 31 32u8 n; 33//------------------------------------------------------------------------------------- 34void TOUCH_KEY() 35{ 36Word j; 37Longword i; 38 //---------Baseline_L------------------------------ 39 Value_Touch_Key_Old=Value_Touch_Key_New; 40 Value_Touch_Key_New=TOUCH_VALUE_H; 41 Value_Touch_Key_New=(Value_Touch_Key_New\u0026lt;\u0026lt;8)+TOUCH_VALUE; 42 43 //------The first check for Touch Key, find out the Baseline_L-------------------------------------------- 44 if(Flag_First_Check==0) 45 { 46 if(Value_Touch_Key_New\u0026gt;=Value_Touch_Key_Old) j=Value_Touch_Key_New-Value_Touch_Key_Old; 47 else j=Value_Touch_Key_Old-Value_Touch_Key_New; 48 49 if(j\u0026lt;=Para_Baseline_Tolerance) 50 { 51 TimesCNT_Baseline++; 52 Temp_Count_Touch_Key+=Value_Touch_Key_New; 53 if(TimesCNT_Baseline\u0026gt;=Para_TimesCNT_Baseline_First_ON) 54 { 55 i=Temp_Count_Touch_Key/Para_TimesCNT_Baseline_First_ON; 56 BaseLine=(u16)i; 57 TimesCNT_Baseline=0; 58 Temp_Count_Touch_Key=0; 59 Flag_First_Check=1; 60 61 Key_Status=1; 62 } 63 } 64 else 65 { 66 TimesCNT_Baseline=0; 67 Temp_Count_Touch_Key=0; 68 } 69 } 70 //----------After the first check the touch key-------------------------- 71 else 72 { 73 if(Flag_Get_Baseline==0) 74 { 75 if(n\u0026lt;20) 76 { 77 n++; 78 Temp_Count_Touch_Key+=Value_Touch_Key_New; 79 } 80 else 81 { 82 n=0; 83 Temp_Value_Touch_Key=(Word)(Temp_Count_Touch_Key/20); 84 Temp_Count_Touch_Key=0; 85 Flag_Get_Baseline=1; 86 } 87 } 88 if(Flag_Get_Baseline) 89 { 90 if((Value_Touch_Key_New\u0026lt;=Temp_Value_Touch_Key+Para_Baseline_Tolerance)\u0026amp;\u0026amp;(Value_Touch_Key_New\u0026gt;=Temp_Value_Touch_Key-Para_Baseline_Tolerance)) 91 { 92 TimesCNT_Baseline++; 93 if(TimesCNT_Baseline\u0026gt;=Para_TimesCNT_Baseline) 94 { 95 TimesCNT_Baseline=0; 96 BaseLine=Temp_Value_Touch_Key; 97 Flag_First_Check=1; 98 Flag_Get_Baseline=0; 99 } 100 } 101 else 102 { 103 Flag_Get_Baseline=0; 104 TimesCNT_Baseline=0; 105 Temp_Value_Touch_Key=0; 106 } 107 } 108 } 109 110 //-------------------------------------------------------------------------- 111 if(BaseLine\u0026gt;0) 112 { 113 //-----------Key_Scan-------------------------- 114 if(Value_Touch_Key_New\u0026gt;=BaseLine+Gap_Leg_In) {Key_Value=1;Key_Mid=0;} 115 else if(Value_Touch_Key_New\u0026lt;BaseLine+Para_Baseline_Tolerance) {Key_Value=0;Key_Mid=0;} 116 else Key_Mid=1; 117 118 if(Key_Mid==0) 119 { 120 if(Key_Value==1) 121 { 122 if(Key_CNT_Pressed\u0026lt;600) Key_CNT_Pressed++; 123 124 if(Key_CNT_Pressed==500) 125 { 126 Touch_ok=2; 127 SET(Key_Handled); 128 } 129 Key_CNT_Off=0; 130 } 131 else 132 { 133 if(Key_CNT_Off\u0026lt;2) Key_CNT_Off++; 134 else 135 { 136 if(Key_CNT_Pressed\u0026gt;=10\u0026amp;\u0026amp;Key_CNT_Pressed\u0026lt;150) 137 { 138 Touch_ok=1; 139 SET(Key_Handled); 140 } 141 Key_CNT_Pressed=0; 142 } 143 } 144 } 145 } 146 147}  本文完整源码已上传本人gitee，点击查看。\n","date":"2018-12-27","img":"","permalink":"/zh-cn/docs/hetai-project/","series":["文档"],"tags":["合泰"],"title":"合泰项目"},{"categories":["电赛项目"],"content":"项目简介  要求小车实现定时一分钟充电，并根据红外接收情况实现小车爬坡循迹行驶。\n项目实现  通过ST89C51系列芯片，使用AD软件实现小车底座电路板PCB绘制，结合无线充电模块和4路红外发射接收模块，通过单片机延时程序实现一分钟的定时充电，并根据红外接收情况实现小车爬坡循迹行驶。\n具体步骤  通过设计要求，实现IO控制，定时器控制，实现定时充电，循迹等功能，以 循迹视频 为例：\n","date":"2018-07-16","img":"","permalink":"/zh-cn/docs/electronic-contest/","series":["文档"],"tags":["电赛"],"title":"电赛项目"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"/zh-cn/offline/","series":null,"tags":null,"title":"Offline"}]